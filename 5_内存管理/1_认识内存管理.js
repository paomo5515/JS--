/* 
  不管以什么样的方式来管理内存，内存的管理都会有如下的生命周期：
    第一步：分配申请你需要的内存(申请)
    第二步：使用分配的内存(存放一些东西，比如对象等)
    第三步：不需要使用时，对其进行释放。

  JS 在定义变量的时候为我们分配内存。

  JS 对于基本数据类型内存的分配会在执行时，直接在 栈空间进行分配。
  JS 对于复杂数据类型内存的分配会在 堆内存中开辟一块空间，并且这
块空间的指针返回变量引用。

  因为内存的大小是有限的，所以当内存不再需要的时候，我们需要对其
进行释放，以便腾出更多的内存空间。
  垃圾回收器的英文是 Garbage Collection，简称GC;
  对于那些不再使用的对象，我们都称之为是垃圾，它需要被回收，以释放更多的内存空间。
  垃圾回收器我们也会简称为 GC，所以在很多地方你看到 GC 其实指的是垃圾回收器。

 */

// 常见的 GC 算法 - 引用计数
var obj = { name: "hello" }

var info = { name: "tom", friend: obj }

var p = { name: "jerry", friend: obj }
// info 中的 friend 指向 obj
// p 中的 friend 指向 obj
// 有人指向它，就会把当前 计数器 + 1；
// 当引用计数变成 0 的时候，GC 就会回收它

// 引用计数存在一个很大的弊端：循环引用

var obj1 = { friend: obj2 }
var obj2 = { friend: obj1 }
obj1.friend = null
// 如果忘记了  就产生循环应用

// 常见的 GC 算法 - 标记清除
// 这个算法是设置一个跟对象(root object)，垃圾回收器会定期从这个根开始，找所有从根
// 开始有引用的对象，对用那些没有引用到的对象，就认为是不可用的对象。
// 这个算法可以很好的解决循环引用的问题

// 目前 JS 引擎主要采用 标记算法和其它的算法